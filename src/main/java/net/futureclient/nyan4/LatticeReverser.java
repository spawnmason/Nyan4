package net.futureclient.nyan4;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;

public class LatticeReverser {

    public static long crackOptimizedDoesntMakeSense(int rngMeasurement1, int rngMeasurement2, int rngMeasurement3) {
        // THIS IS THE VERSION OF THE FUNCTION THAT IS OPTIMIZED TO TAKE LESS THAN 50 NANOSECONDS AND UNCOMMENTED AND WON'T MAKE SENSE
        // it's the same logic as below just optimized :)
        // except, we average the min and max of the bounds BEFORE multiplying by the inverted LLL basis matrix (this is very unintuitive but hey, a linear map is a linear map)
        long bound0Mid = ((long) rngMeasurement1 << 24) + ((1L << 23) - ADDEND_1);
        long bound1Mid = ((long) rngMeasurement2 << 24) + ((1L << 23) - ADDEND_2);
        long bound2Mid = ((long) rngMeasurement3 << 24) + ((1L << 23) - ADDEND_3);
        double bound0 = invBasis00 * bound0Mid + invBasis01 * bound1Mid + invBasis02 * bound2Mid;
        double bound1 = invBasis10 * bound0Mid + invBasis11 * bound1Mid + invBasis12 * bound2Mid;
        double bound2 = invBasis20 * bound0Mid + invBasis21 * bound1Mid + invBasis22 * bound2Mid;
        long result0 = Math.round(bound0);
        long result1 = Math.round(bound1);
        long result2 = Math.round(bound2);
        long seed = (result0 * basisFirstRow0 + result1 * basisFirstRow1 + result2 * basisFirstRow2) & LCG_MASK;
        long next = (seed * LCG_MULT + LCG_ADD) & LCG_MASK;
        long nextNext = (next * LCG_MULT + LCG_ADD) & LCG_MASK;
        if ((((seed >> 24) ^ rngMeasurement1) | ((next >> 24) ^ rngMeasurement2) | ((nextNext >> 24) ^ rngMeasurement3)) != 0) {
            return -1;
        }
        return ((seed - LCG_ADD) * 0xdfe05bcb1365L) & LCG_MASK;
    }

    private static final long LCG_MULT = 0x5DEECE66DL;
    private static final long LCG_ADD = 0xB;
    private static final long LCG_MASK = (1L << 48) - 1;
    // ^ all from java.util.Random
    private static final long ADDEND_1 = 0;
    private static final long ADDEND_2 = LCG_ADD;
    private static final long ADDEND_3 = LCG_ADD * LCG_MULT + LCG_ADD;
    private static final long[] ADDENDS = {ADDEND_1, ADDEND_2, ADDEND_3};
    private static final Rational[][] invertedBasis = new Rational[3][3];
    private static final double invBasis00 = 9.555378710501827E-11D;
    private static final double invBasis01 = -2.5481838861196593E-10D;
    private static final double invBasis02 = 1.184083942007419E-10D;
    private static final double invBasis10 = -1.2602185961441137E-10D;
    private static final double invBasis11 = 6.980727107475104E-11D;
    private static final double invBasis12 = 1.5362999761237006E-10D;
    private static final double invBasis20 = -1.5485213111787743E-10D;
    private static final double invBasis21 = -1.2997958265259513E-10D;
    private static final double invBasis22 = -5.6285642813236336E-11D;
    private static final long basisFirstRow0 = 1270789291L;
    private static final long basisFirstRow1 = -2355713969L;
    private static final long basisFirstRow2 = -3756485696L;
    private static final BigInteger[] basisFirstRow = new BigInteger[3];

    static {
        /* Generated by Mathematica as follows: (note that a is LCG_MULT, b is LCG_ADD, c is LCG_MASK+1)
            a = 25214903917; b = 11; c = 2^48;
            lllBasis = Transpose[LatticeReduce[{{1, a, a^2}, {0, c, 0}, {0, 0, c}}]];
            invBasis = Inverse[lllBasis];
        */
        long[][] lllBasis = new long[][]{
                {1270789291L, -2355713969L, -3756485696L},
                {-2446815537L, 1026597795, -2345310016L},
                {2154219555L, 4110294631L, -2015749696L}
        };
        int[][] invBasisNumerators = new int[][]{
                {26896, -71725, 33329},
                {-35472, 19649, 43243},
                {-43587, -36586, -15843}
        };
        long denominator = 281474976710656L; // Sqrt[Det[lllBasis]]
        BigInteger denom = BigInteger.valueOf(denominator);
        double[][] invertedFloat = new double[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                invertedBasis[i][j] = new Rational(BigInteger.valueOf(invBasisNumerators[i][j]), denom);
                invertedFloat[i][j] = invBasisNumerators[i][j] / (double) denominator;
                if (Math.abs(invertedFloat[i][j] - invertedBasis[i][j].toDouble()) > 0.0000000000000000000000001) {
                    throw new IllegalStateException();
                }
            }
            basisFirstRow[i] = BigInteger.valueOf(lllBasis[0][i]);
        }
        if (basisFirstRow0 != lllBasis[0][0] || basisFirstRow1 != lllBasis[0][1] || basisFirstRow2 != lllBasis[0][2]) {
            throw new IllegalStateException(); // we only care about recovering the coefficient of {1, a, a^2} (no one cares how many times nextSeed wrapped around 2^48 for the second and third measurements)
        }
        if (invBasis00 != invertedFloat[0][0] || invBasis01 != invertedFloat[0][1] || invBasis02 != invertedFloat[0][2] ||
                invBasis10 != invertedFloat[1][0] || invBasis11 != invertedFloat[1][1] || invBasis12 != invertedFloat[1][2] ||
                invBasis20 != invertedFloat[2][0] || invBasis21 != invertedFloat[2][1] || invBasis22 != invertedFloat[2][2]) {
            throw new IllegalStateException();
        }
    }

    public static long crackMakesSense(int rngMeasurement1, int rngMeasurement2, int rngMeasurement3) {
        // THIS IS THE VERSION OF THE FUNCTION THAT MAKES SENSE
        // (although it's 40x slower than the optimized one)
        // goal is to find a seed that would produce these rng measurements
        int[] rngMeasurements = {rngMeasurement1, rngMeasurement2, rngMeasurement3}; // concretely, we want seed such that seed>>24==rngMeasurement1 and nextSeed(seed)>>24==rngMeasurement2 and nextSeed(nextSeed(seed))>>24==rngMeasurement3
        // source for all this: https://gist.github.com/EDDxample/38a9acddcd29f15af034fd91da93b8fa
        // consider the 3d point cloud of seeds (aka vectors that look like {seed, nextSeed(seed), nextSeed(nextSeed(seed))}
        // this is a lattice since it's expressible as integer linear combinations of {1, 0x5DEECE66DL, 0x5DEECE66DL^2} and {0, 2^48, 0} and {0, 0, 2^48} (after subtracting out the ADDEND)
        // the coefficient of the first vector will be seed, the second and third one are just accounting for modulo wraparound
        // we have a 3d cubic constraint on that: our rngMeasurements are the most significant 24 bits of the seed, so it constrains our points to [rngMeasurement[axis]*2^24, (rngMeasurement[axis]+1)*2^24) on each of the three axes
        // lattice reduction allows us to reshape that cube into a tiny polytope where we can just round the bounds to the nearest integer, then go back into the original lattice space via integer change of basis
        // once we've found any lattice point in our cube, that means the first vector coefficient of that lattice point will be a seed that generates the desired rngMeasurements, which is exactly what the point of this functions is to find
        Rational[][] bounds = new Rational[3][2];
        for (int i = 0; i < 3; i++) {
            if (rngMeasurements[i] < 0 || rngMeasurements[i] >= (1 << 24)) {
                throw new IllegalArgumentException();
            }
            // the simplification of s . {1, a, a^2} is ADDENDS away from the reality of s, a s+b, (a s + b) s + b (in other words, subtract this addend to make the lattice include (0,0,0)
            // after subtracting out the lcg addend, we have measured the internal seed to be between min and max (in other words, we observed the most significant 24 bits)
            long min = ((long) rngMeasurements[i] << 24) - ADDENDS[i];
            long max = min + ((1L << 24) - 1);
            bounds[i][0] = new Rational(BigInteger.valueOf(min), BigInteger.ONE);
            bounds[i][1] = new Rational(BigInteger.valueOf(max), BigInteger.ONE);
        }
        BigInteger[] result = new BigInteger[3];
        for (int i = 0; i < 3; i++) {
            // matmul(inverted,bounds)
            Rational boundA = invertedBasis[i][0].multiply(bounds[0][0]).add(invertedBasis[i][1].multiply(bounds[1][0])).add(invertedBasis[i][2].multiply(bounds[2][0]));
            Rational boundB = invertedBasis[i][0].multiply(bounds[0][1]).add(invertedBasis[i][1].multiply(bounds[1][1])).add(invertedBasis[i][2].multiply(bounds[2][1]));
            // if the crack were more difficult we'd need some hilariously complicated algorithm to pick an option that's in the middle of the range, but in practice we have three consecutive 24 bit measurements so this works perfectly every time
            // note that boundA and boundB should always round to the same value but let's just be paranoid
            Rational bound = boundA.add(boundB).multiply(Rational.ONE_HALF);
            result[i] = bound.round();
            // boundA and boundB are always close to each other even if rngMeasurements are bad - not worth checking
            // the real check is how close the bound is to an integer
            /*double err = bound.add(new Rational(result[i], BigInteger.valueOf(-1))).toDouble();
            System.out.println(err);*/
            // it's always very close to an integer (like, within 0.003) for real data, and for fake data (actually random measurements), it's three random floats
            // in theory, we could do something like "if err > 0.01 for at least two of the three bounds then this is bad data" but in practice it's simpler easier and faster to directly test whether this seed would actually produce these measurements (which we do down below after this loop)
        }
        // the LLL reduction is an integer linear combination, so, assuming we found an integer point in the transformed polytope, then the LLLbasis x result should be the coefficients of {{1, a, a^2}, {0, c, 0}, {0, 0, c}} that end up in our cube
        // so the idea was that by going into LLL-transformed basis space, we could easily find an extremely close integer point just by rounding, then transform that by multiplying by the LLL basis (also integers) to end up at a lattice point that is within our original cube bounds, which is exactly what we need
        // (the key is that set of points in the original lattice is exactly the same as the set of points in our LLL reduced lattice, but finding a lattice point is much easier with the reduced basis vectors)
        long seed = result[0].multiply(basisFirstRow[0]).add(result[1].multiply(basisFirstRow[1])).add(result[2].multiply(basisFirstRow[2])).longValue(); // as before, we only care about the coefficient of {1, a, a^2} since that is the seed
        if (seed >> 24 != rngMeasurement1 || nextSeed(seed) >> 24 != rngMeasurement2 || nextSeed(nextSeed(seed)) >> 24 != rngMeasurement3) {
            // verify that the seed is correct by checking that it produces the same measurements
            // in theory we would at this point want to go back and check other potential values between/near boundA and boundB, but in practice this always works lol
            return -1;
        }
        return prevSeed(seed); // Random.next steps the seed forward before returning the value, this seed we have is the internal seed that was returned to create rngMeasurement1, so we need to step it back by one to get the seed that was actually used
    }

    private static long nextSeed(long seed) {
        return (seed * LCG_MULT + LCG_ADD) & LCG_MASK;
    }

    private static long prevSeed(long nextseed) {
        return ((nextseed - LCG_ADD) * 0xdfe05bcb1365L) & LCG_MASK;
    }

    public static class Rational {
        private static final Rational ONE_HALF = new Rational(BigInteger.ONE, BigInteger.valueOf(2));
        private final BigInteger num;
        private final BigInteger denom;

        public Rational(BigInteger num, BigInteger denom) {
            if (denom.signum() == 0) {
                throw new IllegalArgumentException();
            }
            if (denom.signum() == -1) {
                num = num.negate();
                denom = denom.negate();
            }
            // "why no gcd?"
            // unnecessary and makes the overall runtime 10x slower
            this.num = num;
            this.denom = denom;
        }

        public Rational add(Rational other) {
            if (denom.equals(other.denom)) {
                return new Rational(num.add(other.num), denom);
            }
            return new Rational(num.multiply(other.denom).add(other.num.multiply(denom)), denom.multiply(other.denom));
        }

        public Rational multiply(Rational other) {
            return new Rational(num.multiply(other.num), denom.multiply(other.denom));
        }

        public double toDouble() {
            return new BigDecimal(num).divide(new BigDecimal(denom), MathContext.DECIMAL64).doubleValue();
        }

        public BigInteger floor() {
            if (num.signum() == -1) {
                return num.divide(denom).subtract(BigInteger.ONE);
            } else {
                return num.divide(denom);
            }
        }

        public BigInteger round() {
            return add(ONE_HALF).floor();
        }
    }
}
